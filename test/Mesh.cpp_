
#include "Mesh.hpp"
#include <vector>


    
void Mesh::generate()
{
  if (!m_vao) glGenVertexArrays( 1, &m_vao);
  if (!m_vbo) glGenBuffers( 1, &m_vbo);
}

void Mesh::destroy()
{
  if (m_vao)
  {
    glDeleteVertexArrays( 1, &m_vao);
    m_vao = 0u;
  }
  
  if (m_vbo)
  {
    glDeleteBuffers( 1, &m_vbo);
    m_vbo = 0u;
  }
  
  if (m_ibo)
  {
    glDeleteBuffers( 1, &m_ibo);
    m_ibo = 0u;
  }
}


void Mesh::setDatas( void* vertices, size_t numVertices,
                     void* indices, size_t numIndices,
                     GLenum usage)
{
  assert( NULL != vertices );
  
  generate();
  
  GLsizeiptr bufferSize = 3 * sizeof(float) * numVertices;
  m_numTriangles = numVertices / 3;
  
  // CUDA buffer setup
  m_inVertices.resizeDiscard( bufferSize );
  m_outVertices.resizeDiscard( bufferSize );
  m_indices.resizeDiscard( m_numTriangles * 3 * sizeof(GLuint) );
  
  float* inputVertexPtr = (float*)m_inVertices.getMutablePtr();
  float* pVertices = (float*)vertices;
  for (int i = 0; i < numVertices; ++i)
  {
    inputVertexPtr[i] = pVertices[i];
  }
  
  GLuint* vertexIndexPtr = (GLuint*)m_indices.getMutablePtr();
  GLuint* pIndices = (GLuint*)indices;
  for (int i = 0; i < numIndices; ++i)
  {
    inputVertexPtr[i] = pIndices[i];
  }
  
  
  // OpenGL buffers setup
  glBindVertexArray( m_vao );
  {
    glBindBuffer( GL_ARRAY_BUFFER, m_vbo);
      glBufferData( GL_ARRAY_BUFFER, bufferSize, vertices, usage);
      glVertexAttribPointer( VATTRIB_POSITION, 3, GL_FLOAT, GL_FALSE, 0, (void*)(0));
    glBindBuffer( GL_ARRAY_BUFFER, 0u);
    
    
    if (NULL != indices)
    {
      m_numIndices = numIndices;
      
      glGenBuffers( 1, &m_ibo);
      glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, m_ibo);
      glBufferData( GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint)*m_numIndices, indices, 
                    usage); 
      glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0u);
    }
  }
  glBindVertexArray( 0u );
}

void Mesh::draw() const
{
  enable();
    
  if (m_ibo) {
    glDrawElements( GL_TRIANGLES, getNumIndices(), GL_UNSIGNED_INT, 0);
  }else{
    glDrawArrays( GL_TRIANGLES, 0, getNumVertices());
  }
  
  disable();
}


void Mesh::enable() const
{  
  glBindVertexArray( m_vao );  
  glEnableVertexAttribArray( VATTRIB_POSITION );
  
  if (m_ibo) {
    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, m_ibo);
  }
}

void Mesh::disable() const
{
  glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0u);
  
 	glDisableVertexAttribArray( VATTRIB_POSITION );
  
  glBindVertexArray( 0u );
}


//--------------------------------------------------------

namespace meshUtils {

void setup_cubeMesh(Mesh& mesh)
{
  float packed_vertices[] = 
  {
    -1.0f, -1.0f, -1.0f, //0
    -1.0f, -1.0f, +1.0f, //1
    -1.0f, +1.0f, -1.0f, //2
    -1.0f, +1.0f, +1.0f, //3
    +1.0f, -1.0f, -1.0f, //4
    +1.0f, -1.0f, +1.0f, //5
    +1.0f, +1.0f, -1.0f, //6
    +1.0f, +1.0f, +1.0f  //7
  };
  
  unsigned int triangles_indices[] = 
  {
    7, 3, 1,      7, 1, 5,
    7, 5, 6,      6, 5, 4,
    6, 4, 2,      2, 4, 0,
    2, 0, 3,      3, 0, 1,
    3, 7, 6,      3, 6, 2,
    5, 1, 0,      5, 0, 4
  };
  
  size_t numVertices = sizeof(packed_vertices) / sizeof(packed_vertices[0]);
  size_t numIndices = sizeof(triangles_indices) / sizeof(triangles_indices[0]);
  
  mesh.setDatas(packed_vertices, numVertices,
                triangles_indices, numIndices,                  
                GL_STATIC_DRAW );
}

} // namespace meshUtils

